{"ast":null,"code":"import { useRef, useState, useEffect } from 'react';\nimport { loadModules } from 'esri-loader';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction isItem(map) {\n  return typeof map === 'string' || !!map.baseMap || !!map.operationalLayers;\n}\n\nfunction loadView(map, options) {\n  return isItem(map) ? loadItem(map, options) : loadMap(map, options);\n}\n\nfunction loadMap(mapProperties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var viewModule = \"esri/views/\" + (options.isScene ? 'Scene' : 'Map') + \"View\";\n  return loadModules(['esri/Map', viewModule]).then(function (_ref) {\n    var Map = _ref[0],\n        ViewClass = _ref[1]; // then we create a map (or scene)\n\n    var map = new Map(_extends({}, mapProperties)); // and return a view with that map (or scene)\n\n    var _options = options,\n        view = _options.view;\n    return new ViewClass(_extends({}, view, {\n      map: map\n    }));\n  });\n}\n\nfunction loadItem(item, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var modules = options.isScene ? ['esri/views/SceneView', 'esri/WebScene'] : ['esri/views/MapView', 'esri/WebMap'];\n  return loadModules(modules).then(function (_ref2) {\n    var ViewClass = _ref2[0],\n        MapClass = _ref2[1]; // then we create a wem map (or scene) from the item\n\n    var map = typeof item === 'string' ? new MapClass({\n      portalItem: {\n        id: item\n      }\n    }) : MapClass.fromJSON(item); // and return a view with that web map (or scene)\n\n    var _options2 = options,\n        view = _options2.view;\n    return new ViewClass(_extends({}, view, {\n      map: map\n    }));\n  });\n}\n\nfunction destroyView(view) {\n  if (!view) {\n    return;\n  } // undocumented way to destroy a view\n\n\n  view = view.container = null;\n}\n\nfunction useWebMap(item, options) {\n  return useView(item, options);\n}\n\nfunction useWebScene(item, options) {\n  return useView(item, _extends({}, options, {\n    isScene: true\n  }));\n}\n\nfunction useMap(map, options) {\n  return useView(map, options);\n}\n\nfunction useScene(map, options) {\n  return useView(map, _extends({}, options, {\n    isScene: true\n  }));\n}\n\nfunction useView(map, options) {\n  // create a ref to element to be used as the map's container\n  var elRef = useRef(null); // hold on to the view in state\n\n  var _useState = useState(null),\n      view = _useState[0],\n      setView = _useState[1]; // use a ref so we can use initial values in a componentDidMount-like effect\n  // otherwise we'd get a lint error, or have to make it a dependency of the effect\n  // see: https://github.com/facebook/react/issues/15865#issuecomment-540715333\n\n\n  var initialArguments = useRef({\n    map: map,\n    options: options\n  }); // use a side effect to create the view after react has rendered the DOM\n\n  useEffect(function () {\n    var load = function load() {\n      try {\n        var _initialArguments$cur = initialArguments.current,\n            _map = _initialArguments$cur.map,\n            _options = _initialArguments$cur.options;\n        return Promise.resolve(loadView(_map, _options)).then(function (_loadView) {\n          _view = _loadView;\n\n          if (cancelled) {\n            return;\n          } // show the view at the element & add it to the state\n\n\n          _view.container = elRef.current;\n          setView(_view);\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }; // define local variables to be used in the clean up function\n\n\n    var cancelled = false;\n\n    var _view;\n\n    load();\n    return function cleanUp() {\n      // cancel any pending attempts to load the view\n      // see: https://juliangaramendy.dev/use-promise-subscription/\n      cancelled = true; // clean up the map view\n\n      destroyView(_view);\n    };\n  }, []); // similar to componentDidMount(), componentWillUnmount()\n  // return the ref and the view\n\n  return [elRef, view];\n}\n\nfunction useGraphics(view, jsonGraphics) {\n  useEffect(function () {\n    if (!view || !jsonGraphics) {\n      return;\n    }\n\n    var graphics;\n    loadModules(['esri/Graphic']).then(function (_ref) {\n      var Graphic = _ref[0];\n      graphics = jsonGraphics.map(function (jsonGraphic) {\n        return new Graphic(jsonGraphic);\n      });\n      view.graphics.addMany(graphics);\n    });\n    return function removeGraphics() {\n      view && view.graphics.removeMany(graphics);\n    };\n  }, [view, jsonGraphics]);\n}\n\nfunction useGraphic(view, jsonGraphic) {\n  return useGraphics(view, [jsonGraphic]);\n}\n\nfunction useEvents(obj, names, callback) {\n  useEffect(function () {\n    if (!obj) {\n      return;\n    }\n\n    var handles = names.map(function (name) {\n      return obj.on(name, callback);\n    });\n    return function removeHandles() {\n      handles.forEach(function (handle) {\n        handle.remove();\n      });\n    };\n  }, [obj, names, callback]);\n}\n\nfunction useEvent(obj, name, callback) {\n  useEvents(obj, [name], callback);\n}\n\nfunction useWatches(obj, names, callback) {\n  useEffect(function () {\n    if (!obj) {\n      return;\n    }\n\n    var handles = names.map(function (name) {\n      return obj.watch(name, callback);\n    });\n    return function removeHandles() {\n      handles.forEach(function (handle) {\n        handle.remove();\n      });\n    };\n  }, [obj, names, callback]);\n}\n\nfunction useWatch(obj, name, callback) {\n  useWatches(obj, [name], callback);\n}\n\nexport { useEvent, useEvents, useGraphic, useGraphics, useMap, useScene, useWatch, useWatches, useWebMap, useWebScene };","map":{"version":3,"sources":["../src/utils/arcgis.ts","../src/hooks/view.ts","../src/hooks/graphics.ts","../src/hooks/handlers.ts"],"names":["map","loadView","options","isItem","loadItem","loadMap","mapProperties","viewModule","Map","ViewClass","view","item","modules","MapClass","portalItem","id","destroyView","useWebMap","useView","useWebScene","isScene","useMap","useScene","elRef","useRef","setView","useState","initialArguments","useEffect","cancelled","load","current","_view","useGraphics","jsonGraphics","loadModules","Graphic","graphics","useGraphic","jsonGraphic","useEvents","obj","names","callback","handles","handle","useEvent","name","useWatches","useWatch"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAGA,SAAA,MAAA,CAAA,GAAA,EAAA;EACE,OAAO,OAAA,GAAA,KAAA,QAAA,IAA2B,CAAC,CAACA,GAAG,CAAhC,OAAA,IAA4C,CAAC,CAACA,GAAG,CAAxD,iBAAA;AACD;;SASeC,Q,CAASD,G,EAAUE,O,EAAAA;EACjC,OAAOC,MAAM,CAANA,GAAM,CAANA,GAAcC,QAAQ,CAAA,GAAA,EAAtBD,OAAsB,CAAtBA,GAAuCE,OAAO,CAAA,GAAA,EAArD,OAAqD,CAArD;AACD;;SAEeA,O,CAAQC,a,EAAoBJ,O,EAAAA;MAAAA,OAAAA,KAAAA,KAAAA,C,EAAAA;IAAAA,OAAAA,GAA4B,EAA5BA;;;EAC1C,IAAMK,UAAU,GAAA,iBAAiBL,OAAO,CAAPA,OAAAA,GAAAA,OAAAA,GAAjB,KAAA,IAAhB,MAAA;EACA,OAAO,WAAW,CAAC,CAAA,UAAA,EAAZ,UAAY,CAAD,CAAX,CAAA,IAAA,CAA2C,UAAA,IAAA,EAAA;QAAEM,GAAAA,GAAAA,IAAAA,CAAAA,CAAAA,C;QAAKC,SAAAA,GAAAA,IAAAA,CAAAA,CAAAA,C,CAAP,CAChD;;IACA,IAAMT,GAAG,GAAG,IAAA,GAAA,CAAA,QAAA,CAAA,EAAA,EAAZ,aAAY,CAAA,CAAZ,CAFgD,CAEhD;;mBAEiBE,O;QAATQ,IAAAA,GAAAA,QAAAA,CAAAA,I;IACR,OAAO,IAAA,SAAA,CAAA,QAAA,CAAA,EAAA,EAAA,IAAA,EAAA;MAELV,GAAG,EAAHA;IAFK,CAAA,CAAA,CAAP;EALF,CAAO,CAAP;AAUD;;SAEeI,Q,CAASO,I,EAAWT,O,EAAAA;MAAAA,OAAAA,KAAAA,KAAAA,C,EAAAA;IAAAA,OAAAA,GAA4B,EAA5BA;;;EAClC,IAAMU,OAAO,GAAGV,OAAO,CAAPA,OAAAA,GACZ,CAAA,sBAAA,EADYA,eACZ,CADYA,GAEZ,CAAA,oBAAA,EAFJ,aAEI,CAFJ;EAGA,OAAO,WAAW,CAAX,OAAW,CAAX,CAAA,IAAA,CAA0B,UAAA,KAAA,EAAA;QAAEO,SAAAA,GAAAA,KAAAA,CAAAA,CAAAA,C;QAAWI,QAAAA,GAAAA,KAAAA,CAAAA,CAAAA,C,CAAb,CAC/B;;IACA,IAAMb,GAAG,GACP,OAAA,IAAA,KAAA,QAAA,GACI,IAAA,QAAA,CAAa;MACXc,UAAU,EAAE;QACVC,EAAE,EAAEJ;MADM;IADD,CAAb,CADJ,GAMIE,QAAQ,CAARA,QAAAA,CAPN,IAOMA,CAPN,CAF+B,CAE/B;;oBASiBX,O;QAATQ,IAAAA,GAAAA,SAAAA,CAAAA,I;IACR,OAAO,IAAA,SAAA,CAAA,QAAA,CAAA,EAAA,EAAA,IAAA,EAAA;MAELV,GAAG,EAAHA;IAFK,CAAA,CAAA,CAAP;EAZF,CAAO,CAAP;AAiBD;;SAEegB,W,CAAYN,I,EAAAA;EAC1B,IAAI,CAAJ,IAAA,EAAW;IACT;EACD,CAHyBA,CAGzB;;;EAEDA,IAAI,GAAGA,IAAI,CAAJA,SAAAA,GAAPA,IAAAA;AACD;;SC1DeO,S,CAAUN,I,EAAWT,O,EAAAA;EACnC,OAAOgB,OAAO,CAAA,IAAA,EAAd,OAAc,CAAd;AACD;;AAED,SAAgBC,WAAhB,CAA4BR,IAA5B,EAAuCT,OAAvC,EAAuCA;EACrC,OAAOgB,OAAO,CAAA,IAAA,EAAA,QAAA,CAAA,EAAA,EAAA,OAAA,EAAA;IAAqBE,OAAO,EAAE;EAA9B,CAAA,CAAA,CAAd;AACD;;AAED,SAAgBC,MAAhB,CAAuBrB,GAAvB,EAAiCE,OAAjC,EAAiCA;EAC/B,OAAOgB,OAAO,CAAA,GAAA,EAAd,OAAc,CAAd;AACD;;AAED,SAAgBI,QAAhB,CAAyBtB,GAAzB,EAAmCE,OAAnC,EAAmCA;EACjC,OAAOgB,OAAO,CAAA,GAAA,EAAA,QAAA,CAAA,EAAA,EAAA,OAAA,EAAA;IAAoBE,OAAO,EAAE;EAA7B,CAAA,CAAA,CAAd;AACD;;AAED,SAAA,OAAA,CAAA,GAAA,EAAA,OAAA,EAAA;EACE;EACA,IAAMG,KAAK,GAAGC,MAAM,CAApB,IAAoB,CAApB,CAFF,CAEE;;kBAEwBE,QAAQ,CAAA,IAAA,C;MAAzBhB,IAAAA,GAAAA,SAAAA,CAAAA,CAAAA,C;MAAMe,OAAAA,GAAAA,SAAAA,CAAAA,CAAAA,C,CAJf,CAIeA;EAEb;EACA;;;EACA,IAAME,gBAAgB,GAAGH,MAAM,CAAC;IAAExB,GAAG,EAAL,GAAA;IAAOE,OAAO,EAAPA;EAAP,CAAD,CAA/B,CARF,CAQE;;EAGA0B,SAAS,CAAC,YAAA;QAIOE,IAAAA,GAAAA,SAAAA,IAAAA,GAAAA;;oCACYH,gBAAgB,CAACI,O;YAAlC/B,IAAAA,GAAAA,qBAAAA,CAAAA,G;YAAKE,QAAAA,GAAAA,qBAAAA,CAAAA,O;+BACCD,QAAQ,CAAA,IAAA,EAAA,QAAA,C,EAAA,I,CAAA,UAAA,SAAA,EAAA;UAAtB+B,KAAK,GAALA,SAAAA;;UACA,IAAA,SAAA,EAAe;YACb;UACD,CAHqB,CAGrB;;;UAEDA,KAAK,CAALA,SAAAA,GAAkBT,KAAK,CAAvBS,OAAAA;UACAP,OAAO,CAAPA,KAAO,CAAPA;;MACD,C,CAAA,OAAA,CAAA,EAAA;;;MAbO,CACR;;;IACA,IAAII,SAAS,GAAb,KAAA;;IACA,IAAA,KAAA;;IAWAC,IAAI;IACJ,OAAO,SAAA,OAAA,GAAA;MACL;MACA;MACAD,SAAS,GAATA,IAAAA,CAHK,CAGLA;;MAEAb,WAAW,CAAXA,KAAW,CAAXA;IALF,CAAA;EAfO,CAAA,EAATY,EAAS,CAATA,CAXF,CAWEA;EAwBA;;EACA,OAAO,CAAA,KAAA,EAAP,IAAO,CAAP;AACD;;SCrDeK,W,CAAYvB,I,EAAWwB,Y,EAAAA;EACrCN,SAAS,CAAC,YAAA;IACR,IAAI,CAAA,IAAA,IAAS,CAAb,YAAA,EAA4B;MAC1B;IACD;;IAED,IAAA,QAAA;IACAO,WAAW,CAAC,CAAZA,cAAY,CAAD,CAAXA,CAAAA,IAAAA,CAAmC,UAAA,IAAA,EAAA;UAAEC,OAAAA,GAAAA,IAAAA,CAAAA,CAAAA,C;MACnCC,QAAQ,GAAG,YAAY,CAAZ,GAAA,CAAiB,UAAA,WAAA,EAAW;QAAA,OAAI,IAAA,OAAA,CAAJ,WAAI,CAAJ;MAAvCA,CAAW,CAAXA;MACA3B,IAAI,CAAJA,QAAAA,CAAAA,OAAAA,CAAAA,QAAAA;IAFFyB,CAAAA;IAIA,OAAO,SAAA,cAAA,GAAA;MACLzB,IAAI,IAAIA,IAAI,CAAJA,QAAAA,CAAAA,UAAAA,CAARA,QAAQA,CAARA;IADF,CAAA;EAVO,CAAA,EAaN,CAAA,IAAA,EAbHkB,YAaG,CAbM,CAATA;AAcD;;AAED,SAAgBU,UAAhB,CAA2B5B,IAA3B,EAAsC6B,WAAtC,EAAsCA;EACpC,OAAON,WAAW,CAAA,IAAA,EAAO,CAAzB,WAAyB,CAAP,CAAlB;AACD;;SCpBeO,S,CACdC,G,EACAC,K,EACAC,Q,EAAAA;EAEAf,SAAS,CAAC,YAAA;IACR,IAAI,CAAJ,GAAA,EAAU;MACR;IACD;;IACD,IAAMgB,OAAO,GAAG,KAAK,CAAL,GAAA,CAAU,UAAA,IAAA,EAAI;MAAA,OAAIH,GAAG,CAAHA,EAAAA,CAAAA,IAAAA,EAAJ,QAAIA,CAAJ;IAA9B,CAAgB,CAAhB;IACA,OAAO,SAAA,aAAA,GAAA;MACLG,OAAO,CAAPA,OAAAA,CAAgB,UAAA,MAAA,EAAM;QACpBC,MAAM,CAANA,MAAAA;MADFD,CAAAA;IADF,CAAA;EALO,CAAA,EAUN,CAAA,GAAA,EAAA,KAAA,EAVHhB,QAUG,CAVM,CAATA;AAWD;;AAED,SAAgBkB,QAAhB,CAAyBL,GAAzB,EAAmCM,IAAnC,EAAiDJ,QAAjD,EAAiDA;EAC/CH,SAAS,CAAA,GAAA,EAAM,CAAN,IAAM,CAAN,EAATA,QAAS,CAATA;AACD;;AAED,SAAgBQ,UAAhB,CAA2BP,GAA3B,EAAqCC,KAArC,EAAsDC,QAAtD,EAAsDA;EACpDf,SAAS,CAAC,YAAA;IACR,IAAI,CAAJ,GAAA,EAAU;MACR;IACD;;IACD,IAAMgB,OAAO,GAAG,KAAK,CAAL,GAAA,CAAU,UAAA,IAAA,EAAI;MAAA,OAAIH,GAAG,CAAHA,KAAAA,CAAAA,IAAAA,EAAJ,QAAIA,CAAJ;IAA9B,CAAgB,CAAhB;IACA,OAAO,SAAA,aAAA,GAAA;MACLG,OAAO,CAAPA,OAAAA,CAAgB,UAAA,MAAA,EAAM;QACpBC,MAAM,CAANA,MAAAA;MADFD,CAAAA;IADF,CAAA;EALO,CAAA,EAUN,CAAA,GAAA,EAAA,KAAA,EAVHhB,QAUG,CAVM,CAATA;AAWD;;AAED,SAAgBqB,QAAhB,CAAyBR,GAAzB,EAAmCM,IAAnC,EAAiDJ,QAAjD,EAAiDA;EAC/CK,UAAU,CAAA,GAAA,EAAM,CAAN,IAAM,CAAN,EAAVA,QAAU,CAAVA;AACD","sourcesContent":["import { loadModules } from 'esri-loader';\n\n// is this a web map/scene?\nfunction isItem(map: any) {\n  return typeof map === 'string' || !!map.baseMap || !!map.operationalLayers;\n}\n\n// TODO: make this real\nexport interface ILoadViewOptions {\n  isScene?: boolean;\n  view?: any;\n  // [index: string]: any;\n}\n\nexport function loadView(map: any, options?: ILoadViewOptions) {\n  return isItem(map) ? loadItem(map, options) : loadMap(map, options);\n}\n\nexport function loadMap(mapProperties: any, options: ILoadViewOptions = {}) {\n  const viewModule = `esri/views/${options.isScene ? 'Scene' : 'Map'}View`;\n  return loadModules(['esri/Map', viewModule]).then(([Map, ViewClass]) => {\n    // then we create a map (or scene)\n    const map = new Map({ ...mapProperties });\n    // and return a view with that map (or scene)\n    const { view } = options;\n    return new ViewClass({\n      ...view,\n      map,\n    });\n  });\n}\n\nexport function loadItem(item: any, options: ILoadViewOptions = {}) {\n  const modules = options.isScene\n    ? ['esri/views/SceneView', 'esri/WebScene']\n    : ['esri/views/MapView', 'esri/WebMap'];\n  return loadModules(modules).then(([ViewClass, MapClass]) => {\n    // then we create a wem map (or scene) from the item\n    const map =\n      typeof item === 'string'\n        ? new MapClass({\n            portalItem: {\n              id: item,\n            },\n          })\n        : MapClass.fromJSON(item);\n    // and return a view with that web map (or scene)\n    const { view } = options;\n    return new ViewClass({\n      ...view,\n      map,\n    });\n  });\n}\n\nexport function destroyView(view: any) {\n  if (!view) {\n    return;\n  }\n  // undocumented way to destroy a view\n  view = view.container = null;\n}\n","import { useRef, useEffect, useState } from 'react';\nimport { loadView, destroyView, ILoadViewOptions } from '../utils/arcgis';\n\nexport function useWebMap(item: any, options?: ILoadViewOptions) {\n  return useView(item, options);\n}\n\nexport function useWebScene(item: any, options?: ILoadViewOptions) {\n  return useView(item, { ...options, isScene: true });\n}\n\nexport function useMap(map: any, options?: ILoadViewOptions) {\n  return useView(map, options);\n}\n\nexport function useScene(map: any, options?: ILoadViewOptions) {\n  return useView(map, { ...options, isScene: true });\n}\n\nfunction useView(map: any, options?: ILoadViewOptions) {\n  // create a ref to element to be used as the map's container\n  const elRef = useRef(null);\n  // hold on to the view in state\n  const [view, setView] = useState(null);\n  // use a ref so we can use initial values in a componentDidMount-like effect\n  // otherwise we'd get a lint error, or have to make it a dependency of the effect\n  // see: https://github.com/facebook/react/issues/15865#issuecomment-540715333\n  const initialArguments = useRef({ map, options });\n\n  // use a side effect to create the view after react has rendered the DOM\n  useEffect(() => {\n    // define local variables to be used in the clean up function\n    let cancelled = false;\n    let _view: any;\n    async function load() {\n      const { map, options } = initialArguments.current;\n      _view = await loadView(map, options);\n      if (cancelled) {\n        return;\n      }\n      // show the view at the element & add it to the state\n      _view.container = elRef.current;\n      setView(_view);\n    }\n    load();\n    return function cleanUp() {\n      // cancel any pending attempts to load the view\n      // see: https://juliangaramendy.dev/use-promise-subscription/\n      cancelled = true;\n      // clean up the map view\n      destroyView(_view);\n    };\n  }, []); // similar to componentDidMount(), componentWillUnmount()\n\n  // return the ref and the view\n  return [elRef, view];\n}\n","import { useEffect } from 'react';\nimport { loadModules } from 'esri-loader';\n\nexport function useGraphics(view: any, jsonGraphics: any[]) {\n  useEffect(() => {\n    if (!view || !jsonGraphics) {\n      return;\n    }\n\n    let graphics: any[];\n    loadModules(['esri/Graphic']).then(([Graphic]) => {\n      graphics = jsonGraphics.map(jsonGraphic => new Graphic(jsonGraphic));\n      view.graphics.addMany(graphics);\n    });\n    return function removeGraphics() {\n      view && view.graphics.removeMany(graphics);\n    };\n  }, [view, jsonGraphics]);\n}\n\nexport function useGraphic(view: any, jsonGraphic: any) {\n  return useGraphics(view, [jsonGraphic]);\n}\n","import { useEffect } from 'react';\n\nexport function useEvents(\n  obj: any,\n  names: string[],\n  callback: (e: any) => void\n) {\n  useEffect(() => {\n    if (!obj) {\n      return;\n    }\n    const handles = names.map(name => obj.on(name, callback));\n    return function removeHandles() {\n      handles.forEach(handle => {\n        handle.remove();\n      });\n    };\n  }, [obj, names, callback]);\n}\n\nexport function useEvent(obj: any, name: string, callback: (e: any) => void) {\n  useEvents(obj, [name], callback);\n}\n\nexport function useWatches(obj: any, names: string[], callback: any) {\n  useEffect(() => {\n    if (!obj) {\n      return;\n    }\n    const handles = names.map(name => obj.watch(name, callback));\n    return function removeHandles() {\n      handles.forEach(handle => {\n        handle.remove();\n      });\n    };\n  }, [obj, names, callback]);\n}\n\nexport function useWatch(obj: any, name: string, callback: any) {\n  useWatches(obj, [name], callback);\n}\n"]},"metadata":{},"sourceType":"module"}