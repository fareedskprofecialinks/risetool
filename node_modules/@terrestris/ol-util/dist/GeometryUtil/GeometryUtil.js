"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Feature = _interopRequireDefault(require("ol/Feature"));

var _MultiPolygon = _interopRequireDefault(require("ol/geom/MultiPolygon"));

var _MultiPoint = _interopRequireDefault(require("ol/geom/MultiPoint"));

var _MultiLineString = _interopRequireDefault(require("ol/geom/MultiLineString"));

var _GeoJSON = _interopRequireDefault(require("ol/format/GeoJSON"));

var _buffer = _interopRequireDefault(require("@turf/buffer"));

var _difference2 = _interopRequireDefault(require("@turf/difference"));

var _intersect = _interopRequireDefault(require("@turf/intersect"));

var _polygonize = _interopRequireDefault(require("@turf/polygonize"));

var _union2 = _interopRequireDefault(require("@turf/union"));

var _helpers = require("@turf/helpers");

var _meta = require("@turf/meta");

var _lineToPolygon = _interopRequireDefault(require("@turf/line-to-polygon"));

/**
 * Helper class for the geospatial analysis. Makes use of
 * [Turf.js](http://turfjs.org/).
 *
 * @class GeometryUtil
 */
var GeometryUtil = /*#__PURE__*/function () {
  function GeometryUtil() {
    (0, _classCallCheck2["default"])(this, GeometryUtil);
  }

  (0, _createClass2["default"])(GeometryUtil, null, [{
    key: "splitByLine",
    value:
    /**
     * The prefix used to detect multi geometries.
     * @ignore
     */

    /**
     * Splits an ol.feature with/or ol.geom.Polygon by an ol.feature with/or ol.geom.LineString
     * into an array of instances of ol.feature with/or ol.geom.Polygon.
     * If the target polygon (first param) is of type ol.Feature it will return an
     * array with ol.Feature. If the target polygon (first param) is of type
     * ol.geom.Geometry it will return an array with ol.geom.Geometry.
     *
     * @param {ol.Feature | ol.geom.Polygon} polygon The polygon geometry to split.
     * @param {ol.Feature | ol.geom.LineString} line The line geometry to split the polygon
     *  geometry with.
     * @param {ol.ProjectionLike} projection The EPSG code of the input features.
     *  Default is to EPSG:3857.
     * @returns {ol.Feature[] | ol.geom.Polygon[]} An array of instances of ol.feature
     *  with/or ol.geom.Polygon
     */
    function splitByLine(polygon, line) {
      var projection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'EPSG:3857';
      var geoJsonFormat = new _GeoJSON["default"]({
        dataProjection: 'EPSG:4326',
        featureProjection: projection
      });
      var polygonFeat = polygon instanceof _Feature["default"] ? polygon : new _Feature["default"]({
        geometry: polygon
      });
      var lineFeat = line instanceof _Feature["default"] ? line : new _Feature["default"]({
        geometry: line
      }); // Convert the input line features to turf.js/GeoJSON features while
      // reprojecting them to the internal turf.js projection 'EPSG:4326'.

      var turfLine = geoJsonFormat.writeFeatureObject(lineFeat); // This lists all the polygons in the feature and splits the Multi polygons into an array of polygons.

      var geometries = GeometryUtil.separateGeometries(polygonFeat.getGeometry()); // the array containing all the split features

      var allSplitedPolygons = []; // iterates over each polygon and splits it

      geometries.forEach(function (geometry) {
        // Convert the polygon to turf.js/GeoJSON geometry while
        // reprojecting them to the internal turf.js projection 'EPSG:4326'.
        var turfPolygon = geoJsonFormat.writeGeometryObject(geometry);
        var turfPolygonCoordinates = turfPolygon.coordinates; // outer lines of the given polygon

        var outer = (0, _helpers.lineString)(turfPolygonCoordinates[0]); // polygonized outer polygon

        var outerPolygon = (0, _lineToPolygon["default"])(outer); // holes in the polygon

        var inners = [];
        turfPolygonCoordinates.slice(1, turfPolygonCoordinates.length).forEach(function (coord) {
          inners.push((0, _helpers.lineString)(coord));
        }); // Polygonize the holes in the polygon

        var innerPolygon = (0, _polygonize["default"])((0, _helpers.featureCollection)(inners)); // make a lineString from the splitting line and the outer of the polygon

        var unionGeom = (0, _union2["default"])(outer, turfLine); // Polygonize the combined lines.

        var polygonizedUnionGeom = (0, _polygonize["default"])(unionGeom); // Array of the split polygons within the geometry

        var splitedPolygons = []; // Iterate over each feature in the combined feature and remove sections that are outside the initial polygon and
        // remove the parts from the cut polygons that are in polygon holes.

        (0, _meta.featureEach)(polygonizedUnionGeom, function (cuttedSection) {
          // checks to see if segment is in polygon
          var segmentInPolygon = (0, _intersect["default"])(cuttedSection, outerPolygon);

          if (segmentInPolygon && segmentInPolygon.geometry.type === 'Polygon') {
            var polygonWithoutHoles = [];

            if (innerPolygon.features.length > 0) {
              // iterates over all the holes and removes their intersection with the cut polygon
              innerPolygon.features.forEach(function (holes) {
                var toCut = polygonWithoutHoles.length > 0 ? polygonWithoutHoles : [segmentInPolygon];
                toCut.forEach(function (tocutPart, i) {
                  var intersection = (0, _difference2["default"])(tocutPart, holes);

                  if (intersection && (intersection.geometry.type === 'Polygon' || intersection.geometry.type === 'MultiPolygon')) {
                    if (intersection.geometry.type === 'MultiPolygon') {
                      intersection.geometry.coordinates.forEach(function (intersectPolyCoords) {
                        polygonWithoutHoles.push((0, _helpers.polygon)(intersectPolyCoords));
                      });
                    } else {
                      polygonWithoutHoles[i] = intersection;
                    }
                  }
                });
              });
            }

            if (polygonWithoutHoles.length > 0) {
              splitedPolygons.push.apply(splitedPolygons, polygonWithoutHoles);
            } else {
              splitedPolygons.push(segmentInPolygon);
            }
          }
        });
        var collection = (0, _helpers.featureCollection)(splitedPolygons);
        var features = geoJsonFormat.readFeatures(collection);
        allSplitedPolygons = [].concat((0, _toConsumableArray2["default"])(features), (0, _toConsumableArray2["default"])(allSplitedPolygons));
      });

      if (polygon instanceof _Feature["default"]) {
        return allSplitedPolygons;
      } else {
        return allSplitedPolygons.map(function (f) {
          return f.getGeometry();
        });
      }
    }
    /**
     * Adds a buffer to a given geometry.
     *
     * If the target is of type ol.Feature it will return an ol.Feature.
     * If the target is of type ol.geom.Geometry it will return ol.geom.Geometry.
     *
     * @param {ol.geom.Geometry | ol.Feature} geometry The geometry.
     * @param {number} radius The buffer to add in meters.
     * @param {string} projection The projection of the input geometry as EPSG code.
     *  Default is to EPSG:3857.
     *
     * @returns {ol.geom.Geometry | ol.Feature} The geometry or feature with the added buffer.
     */

  }, {
    key: "addBuffer",
    value: function addBuffer(geometry) {
      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var projection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'EPSG:3857';

      if (radius === 0) {
        return geometry;
      }

      var geoJsonFormat = new _GeoJSON["default"]({
        dataProjection: 'EPSG:4326',
        featureProjection: projection
      });
      var geoJson = geometry instanceof _Feature["default"] ? geoJsonFormat.writeFeatureObject(geometry) : geoJsonFormat.writeGeometryObject(geometry);
      var buffered = (0, _buffer["default"])(geoJson, radius, {
        units: 'meters'
      });

      if (geometry instanceof _Feature["default"]) {
        return geoJsonFormat.readFeature(buffered);
      } else {
        return geoJsonFormat.readGeometry(buffered.geometry);
      }
    }
    /**
     * Merges multiple geometries into one MultiGeometry.
     *
     * @param {ol.geom.Geometry[]} geometries An array of ol.geom.geometries;
     * @returns {ol.geom.MultiPoint|ol.geom.MultiPolygon|ol.geom.MultiLineString} A Multigeometry.
     */

  }, {
    key: "mergeGeometries",
    value: function mergeGeometries(geometries) {
      var multiPrefix = GeometryUtil.MULTI_GEOM_PREFIX;
      var geomType = geometries[0].getType();
      var mixedGeometryTypes = false;
      geometries.forEach(function (geometry) {
        if (geomType.replace(multiPrefix, '') !== geometry.getType().replace(multiPrefix, '')) {
          mixedGeometryTypes = true;
        }
      });

      if (mixedGeometryTypes) {
        // Logger.warn('Can not merge mixed geometries into one multigeometry.');
        return undefined;
      } // split all multi-geometries to simple ones if passed geometries are
      // multigeometries


      if (geomType.startsWith(multiPrefix)) {
        var multiGeomPartType = geomType.substring(multiPrefix.length);
        geometries = GeometryUtil.separateGeometries(geometries);
        geomType = multiGeomPartType;
      }

      var multiGeom;
      var append;

      switch (geomType) {
        case 'Polygon':
          multiGeom = new _MultiPolygon["default"]([]);
          append = multiGeom.appendPolygon.bind(multiGeom);
          break;

        case 'Point':
          multiGeom = new _MultiPoint["default"]([]);
          append = multiGeom.appendPoint.bind(multiGeom);
          break;

        case 'LineString':
          multiGeom = new _MultiLineString["default"]([]);
          append = multiGeom.appendLineString.bind(multiGeom);
          break;

        default:
          return undefined;
      }

      geometries.forEach(function (geom) {
        return append(geom);
      });
      return multiGeom;
    }
    /**
     * Splits an array of geometries (and multi geometries) or a single MultiGeom
     * into an array of single geometries.
     *
     * Attention: ol.geom.Circle and ol.geom.LinearRing are not supported.
     *
     * @param {ol.geom.SimpleGeometry|ol.geom.SimpleGeometry[]} geometries An (array of) ol.geom.geometries;
     * @returns {ol.geom.Point[]|ol.geom.Polygon[]|ol.geom.LineString[]} An array of geometries.
     */

  }, {
    key: "separateGeometries",
    value: function separateGeometries(geometries) {
      var separatedGeometries = [];
      geometries = Array.isArray(geometries) ? geometries : [geometries];
      geometries.forEach(function (geometry) {
        var geomType = geometry.getType();

        if (geomType.startsWith(GeometryUtil.MULTI_GEOM_PREFIX)) {
          var multiGeomPartType = geomType.substring(GeometryUtil.MULTI_GEOM_PREFIX.length);

          switch (multiGeomPartType) {
            case 'Polygon':
              separatedGeometries.push.apply(separatedGeometries, (0, _toConsumableArray2["default"])(geometry.getPolygons()));
              break;

            case 'LineString':
              separatedGeometries.push.apply(separatedGeometries, (0, _toConsumableArray2["default"])(geometry.getLineStrings()));
              break;

            case 'Point':
              separatedGeometries.push.apply(separatedGeometries, (0, _toConsumableArray2["default"])(geometry.getPoints()));
              break;

            default:
              break;
          }
        } else {
          separatedGeometries.push(geometry);
        }
      });
      return separatedGeometries;
    }
    /**
     * Takes two or more polygons and returns a combined (Multi-)polygon.
     *
     * @param {ol.geom.Geometry[] | ol.Feature[]} polygons An array of ol.Feature
     *  or ol.geom.Geometry instances of type (Multi-)polygon.
     * @param {string} projection The projection of the input polygons as EPSG code.
     *  Default is to EPSG:3857.
     * @returns {ol.geom.Geometry | ol.Feature} A Feature or Geometry with the
     * combined area of the (Multi-)polygons.
     */

  }, {
    key: "union",
    value: function union(polygons) {
      var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EPSG:3857';
      var geoJsonFormat = new _GeoJSON["default"]({
        dataProjection: 'EPSG:4326',
        featureProjection: projection
      });
      var invalid = false;
      var geoJsonsFeatures = polygons.map(function (geometry) {
        var feature = geometry instanceof _Feature["default"] ? geometry : new _Feature["default"]({
          geometry: geometry
        });

        if (!['Polygon', 'MultiPolygon'].includes(feature.getGeometry().getType())) {
          invalid = true;
        }

        return geoJsonFormat.writeFeatureObject(feature);
      });

      if (invalid) {
        // Logger.warn('Can only create union of polygons.');
        return undefined;
      }

      var unioned = _union2["default"].apply(void 0, (0, _toConsumableArray2["default"])(geoJsonsFeatures));

      var feature = geoJsonFormat.readFeature(unioned);

      if (polygons[0] instanceof _Feature["default"]) {
        return feature;
      } else {
        return feature.getGeometry();
      }
    }
    /**
     * Finds the difference between two polygons by clipping the second polygon from the first.
     *
     * @param {ol.geom.Geometry | ol.Feature} polygon1 An ol.geom.Geometry or ol.Feature
     * @param {ol.geom.Geometry | ol.Feature} polygon2 An ol.geom.Geometry or ol.Feature
     * @param {string} projection The projection of the input polygons as EPSG code.
     *  Default is to EPSG:3857.
     *
     * @returns {ol.geom.Geometry | ol.Feature} A Feature or Geometry with the area
     *  of polygon1 excluding the area of polygon2. The type of the first polygon
     *  (geometry or feature) determines the return type.
     */

  }, {
    key: "difference",
    value: function difference(polygon1, polygon2) {
      var projection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'EPSG:3857';
      var geoJsonFormat = new _GeoJSON["default"]({
        dataProjection: 'EPSG:4326',
        featureProjection: projection
      });
      var feat1 = polygon1 instanceof _Feature["default"] ? polygon1 : new _Feature["default"]({
        geometry: polygon1
      });
      var feat2 = polygon2 instanceof _Feature["default"] ? polygon2 : new _Feature["default"]({
        geometry: polygon2
      });
      var geojson1 = geoJsonFormat.writeFeatureObject(feat1);
      var geojson2 = geoJsonFormat.writeFeatureObject(feat2);
      var intersection = (0, _difference2["default"])(geojson1, geojson2);
      var feature = geoJsonFormat.readFeature(intersection);

      if (polygon1 instanceof _Feature["default"] && polygon2 instanceof _Feature["default"]) {
        return feature;
      } else {
        return feature.getGeometry();
      }
    }
    /**
     * Takes two polygons and finds their intersection.
     *
     * If the polygons are of type ol.Feature it will return an ol.Feature.
     * If the polygons are of type ol.geom.Geometry it will return an ol.geom.Geometry.
     *
     * @param {ol.geom.Geometry | ol.Feature} polygon1 An ol.geom.Geometry or ol.Feature
     * @param {ol.geom.Geometry | ol.Feature} polygon2 An ol.geom.Geometry or ol.Feature
     * @param {string} projection The projection of the input polygons as EPSG code.
     *  Default is to EPSG:3857.
     *
     * @returns {ol.geom.Geometry | ol.Feature} A Feature or Geometry with the
     * shared area of the two polygons or null if the polygons don't intersect.
     */

  }, {
    key: "intersection",
    value: function intersection(polygon1, polygon2) {
      var projection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'EPSG:3857';
      var geoJsonFormat = new _GeoJSON["default"]({
        dataProjection: 'EPSG:4326',
        featureProjection: projection
      });
      var feat1 = polygon1 instanceof _Feature["default"] ? polygon1 : new _Feature["default"]({
        geometry: polygon1
      });
      var feat2 = polygon2 instanceof _Feature["default"] ? polygon2 : new _Feature["default"]({
        geometry: polygon2
      });
      var geojson1 = geoJsonFormat.writeFeatureObject(feat1);
      var geojson2 = geoJsonFormat.writeFeatureObject(feat2);
      var intersection = (0, _intersect["default"])(geojson1, geojson2);

      if (!intersection) {
        return null;
      }

      var feature = geoJsonFormat.readFeature(intersection);

      if (polygon1 instanceof _Feature["default"] && polygon2 instanceof _Feature["default"]) {
        return feature;
      } else {
        return feature.getGeometry();
      }
    }
  }]);
  return GeometryUtil;
}();

(0, _defineProperty2["default"])(GeometryUtil, "MULTI_GEOM_PREFIX", 'Multi');
var _default = GeometryUtil;
exports["default"] = _default;