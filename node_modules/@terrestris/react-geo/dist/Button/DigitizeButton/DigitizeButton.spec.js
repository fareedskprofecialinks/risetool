"use strict";

var _TestUtil = _interopRequireDefault(require("../../Util/TestUtil"));

var _Logger = _interopRequireDefault(require("@terrestris/base-util/dist/Logger"));

var _Vector = _interopRequireDefault(require("ol/source/Vector"));

var _Draw = _interopRequireDefault(require("ol/interaction/Draw"));

var _Select = _interopRequireDefault(require("ol/interaction/Select"));

var _Style = _interopRequireDefault(require("ol/style/Style"));

var _Stroke = _interopRequireDefault(require("ol/style/Stroke"));

var _Fill = _interopRequireDefault(require("ol/style/Fill"));

var _Circle = _interopRequireDefault(require("ol/style/Circle"));

var _Text = _interopRequireDefault(require("ol/style/Text"));

var _Feature = _interopRequireDefault(require("ol/Feature"));

var _Collection = _interopRequireDefault(require("ol/Collection"));

var _Point = _interopRequireDefault(require("ol/geom/Point"));

var _LineString = _interopRequireDefault(require("ol/geom/LineString"));

var _Polygon = _interopRequireDefault(require("ol/geom/Polygon"));

var _DigitizeButton = _interopRequireDefault(require("./DigitizeButton"));

var _MapUtil = _interopRequireDefault(require("@terrestris/ol-util/dist/MapUtil/MapUtil"));

var _AnimateUtil = _interopRequireDefault(require("@terrestris/ol-util/dist/AnimateUtil/AnimateUtil"));

var _ToggleButton = _interopRequireDefault(require("../ToggleButton/ToggleButton"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

describe('<DigitizeButton />', function () {
  var map;
  beforeEach(function () {
    map = _TestUtil["default"].createMap();
  });
  afterEach(function () {
    map = _TestUtil["default"].removeMap();
  });
  /**
   * Wraps the component.
   *
   * @return {Object} The wrapped component.
   */

  var setupWrapper = function setupWrapper() {
    var defaultProps = {
      map: map,
      drawType: 'Point'
    };
    return _TestUtil["default"].mountComponent(_DigitizeButton["default"], defaultProps);
  };
  /**
   * Returns a mock OLInteractionDraw of type Point.
   *
   * @return {Object} The mocked interaction.
   */


  var getMockDrawPointInteraction = function getMockDrawPointInteraction() {
    return new _Draw["default"]({
      source: new _Vector["default"](),
      type: 'Point',
      style: new _Style["default"]({
        stroke: new _Stroke["default"]({
          color: 'red',
          width: 2
        })
      })
    });
  };
  /**
   * Returns a mock OlInteractionSelect .
   *
   * @return {Object} The mocked interaction.
   */


  var getMockSelectInteraction = function getMockSelectInteraction() {
    return new _Select["default"]({
      style: new _Style["default"]({
        stroke: new _Stroke["default"]({
          color: 'red',
          width: 2
        })
      })
    });
  };

  describe('#Basics', function () {
    it('is defined', function () {
      expect(_DigitizeButton["default"]).not.toBeUndefined();
    });
    it('can be rendered', function () {
      var wrapper = setupWrapper();
      expect(wrapper).not.toBeUndefined();
      expect(wrapper.find(_DigitizeButton["default"]).length).toEqual(1);
    });
    it('passes style property to wrapped ToggleButton', function () {
      var style = {
        backgroundColor: 'yellow'
      };
      var wrapper = setupWrapper();
      wrapper.setProps({
        style: style
      });
      var toggleButton = wrapper.find(_ToggleButton["default"]).get(0);
      expect(toggleButton).toBeDefined();
      expect(toggleButton.props.style).toEqual(style);
    });
    it('drawType or editType prop must be provided and have valid values', function () {
      var loggerSpy = jest.spyOn(_Logger["default"], 'warn');

      _TestUtil["default"].mountComponent(_DigitizeButton["default"], {
        map: map
      });

      expect(loggerSpy).toHaveBeenCalledTimes(1);
      expect(loggerSpy).toHaveBeenCalledWith(expect.stringContaining('Neither "drawType" nor "editType" was provided. Digitize ' + 'button won\'t work properly!'));
      loggerSpy.mockRestore();
    });
  });
  describe('#Private methods', function () {
    describe('#onToggle', function () {
      it('calls passed onToggle in props it was provided', function () {
        expect.assertions(1);
        var wrapper = setupWrapper();
        var onToggle = jest.fn();
        wrapper.setProps({
          onToggle: onToggle
        }, function () {
          wrapper.instance().onToggle(true);
          expect(onToggle).toHaveBeenCalledTimes(1);
        });
      });
      it('calls a createDrawInteraction method if button was pressed and valid drawType was provided', function () {
        var wrapper = setupWrapper();
        var createDrawInteraction = jest.spyOn(wrapper.instance(), 'createDrawInteraction');
        wrapper.instance().onToggle(true);
        expect(createDrawInteraction).toHaveBeenCalledTimes(1);
        createDrawInteraction.mockRestore();
      });
      it('calls a createSelectOrModifyInteraction method if button was pressed and valid editType was provided', function () {
        var wrapper = setupWrapper();
        wrapper.setProps({
          drawType: null,
          editType: 'Edit'
        });
        var createSelectOrModifyInteraction = jest.spyOn(wrapper.instance(), 'createSelectOrModifyInteraction');
        wrapper.instance().onToggle(true);
        expect(createSelectOrModifyInteraction).toHaveBeenCalledTimes(1);
        createSelectOrModifyInteraction.mockRestore();
      });
      it('removes all draw/select interactions created by component from the map if the button was untoggled', function () {
        var wrapper = setupWrapper();
        var mockInteraction = getMockDrawPointInteraction();
        var defaultMapInteractionsLength = map.getInteractions().getLength();
        map.addInteraction(getMockDrawPointInteraction());
        map.on('pointermove', wrapper.instance().onPointerMove);
        wrapper.setState({
          interactions: [mockInteraction]
        });
        expect(map.getInteractions().getLength()).toBe(defaultMapInteractionsLength + 1); // Warning: using of private properties such `listeners_` could be
        // a bit fragile. We should probably find another way to get the
        // appropriate value.

        expect(map.listeners_.pointermove).toBeDefined();
        wrapper.instance().onToggle(false);
        expect(map.listeners_.pointermove).toBeUndefined();
      });
      it('unregisters `add` listener on digitize feature collection if drawType is Text and button was untoggled', function () {
        var wrapper = setupWrapper();
        wrapper.setProps({
          drawType: 'Text'
        });
        var mockInteraction = getMockDrawPointInteraction();
        var instance = wrapper.instance();
        instance.createDigitizeLayer();
        instance._digitizeFeatures = instance._digitizeLayer.getSource().getFeaturesCollection();
        map.addInteraction(mockInteraction);

        instance._digitizeFeatures.on('add', wrapper.instance().handleTextAdding);

        expect(instance._digitizeFeatures.listeners_.add.length).toBe(2);
        wrapper.setState({
          interactions: [mockInteraction]
        });
        instance.onToggle(false);
        expect(instance._digitizeFeatures.listeners_.add.length).toBe(1);
      });
      it('unregisters `select` listener on select interaction if editType is Delete and button was untoggled', function () {
        var wrapper = setupWrapper();
        wrapper.setProps({
          drawType: null,
          editType: 'Delete'
        });
        var mockInteraction = getMockSelectInteraction();
        var instance = wrapper.instance();
        instance._selectInteraction = mockInteraction;
        map.addInteraction(mockInteraction);

        instance._selectInteraction.on('select', wrapper.instance().onFeatureRemove);

        expect(instance._selectInteraction.listeners_.select.length).toBe(1);
        wrapper.setState({
          interactions: [mockInteraction]
        });
        instance.onToggle(false);
        expect(instance._selectInteraction.listeners_.select).toBeUndefined();
      });
      it('unregisters `select` listener on select interaction if editType is Copy and button was untoggled', function () {
        var wrapper = setupWrapper();
        wrapper.setProps({
          drawType: null,
          editType: 'Copy'
        });
        var mockInteraction = getMockSelectInteraction();
        var instance = wrapper.instance();
        instance._selectInteraction = mockInteraction;
        map.addInteraction(mockInteraction);

        instance._selectInteraction.on('select', wrapper.instance().onFeatureCopy);

        expect(instance._selectInteraction.listeners_.select.length).toBe(1);
        wrapper.setState({
          interactions: [mockInteraction]
        });
        instance.onToggle(false);
        expect(instance._selectInteraction.listeners_.select).toBeUndefined();
      });
    });
    describe('#createDigitizeLayer', function () {
      it('creates a digitize vector layer, adds this to the map and assigns its value to state', function () {
        var digitizeLayer = _MapUtil["default"].getLayerByName(map, 'react-geo_digitize');

        expect(digitizeLayer).toBeUndefined();
        var wrapper = setupWrapper();
        digitizeLayer = _MapUtil["default"].getLayerByName(map, 'react-geo_digitize');
        expect(digitizeLayer).toBeDefined();
        expect(wrapper.instance()._digitizeLayer).toBe(digitizeLayer);
      });
    });
    describe('#getDigitizeStyleFunction', function () {
      it('returns a valid OlStyleStyle object depending on feature geometry type', function () {
        var wrapper = setupWrapper();
        var pointFeature = new _Feature["default"](new _Point["default"]([0, 0]));
        var lineFeature = new _Feature["default"](new _LineString["default"]([0, 0], [1, 1]));
        var polyFeature = new _Feature["default"](new _Polygon["default"]([0, 0], [0, 1], [1, 1], [0, 0]));
        var pointStyle = wrapper.instance().getDigitizeStyleFunction(pointFeature);
        expect(pointStyle instanceof _Style["default"]).toBeTruthy();
        expect(_typeof(pointStyle)).toBe('object');
        expect(pointStyle.getImage() instanceof _Circle["default"]).toBeTruthy();
        pointFeature.set('isLabel', true);
        var labelStyle = wrapper.instance().getDigitizeStyleFunction(pointFeature);
        expect(labelStyle instanceof _Style["default"]).toBeTruthy();
        expect(_typeof(labelStyle)).toBe('object');
        expect(labelStyle.getText() instanceof _Text["default"]).toBeTruthy();
        var lineStyle = wrapper.instance().getDigitizeStyleFunction(lineFeature);
        expect(lineStyle instanceof _Style["default"]).toBeTruthy();
        expect(_typeof(lineStyle)).toBe('object');
        expect(lineStyle.getStroke() instanceof _Stroke["default"]).toBeTruthy();
        var polyStyle = wrapper.instance().getDigitizeStyleFunction(polyFeature);
        expect(polyStyle instanceof _Style["default"]).toBeTruthy();
        expect(_typeof(polyStyle)).toBe('object');
        expect(polyStyle.getStroke() instanceof _Stroke["default"]).toBeTruthy();
        expect(polyStyle.getFill() instanceof _Fill["default"]).toBeTruthy();
      });
    });
    describe('#getSelectedStyleFunction', function () {
      it('returns a valid OlStyleStyle object to be used with selected features', function () {
        var wrapper = setupWrapper();
        wrapper.setProps({
          selectFillColor: '#ff0000',
          selectStrokeColor: '#0000ff'
        });
        var expectedStyle = wrapper.instance().getSelectedStyleFunction(new _Feature["default"]());
        expect(expectedStyle instanceof _Style["default"]).toBeTruthy();
        expect(expectedStyle.getStroke().getColor()).toBe(wrapper.props().selectStrokeColor);
        expect(expectedStyle.getFill().getColor()).toBe(wrapper.props().selectFillColor);
      });
    });
    describe('#createDrawInteraction', function () {
      it('creates OL draw interaction depending on provided drawType and sets its value to state', function () {
        var wrapper = setupWrapper();
        wrapper.setProps({
          drawType: 'Rectangle'
        });
        wrapper.instance().createDrawInteraction(true);
        expect(wrapper.instance()._interactions.length).toBe(1);
        expect(wrapper.instance()._interactions[0].type_).toBe('Circle');
        wrapper.setState({
          interactions: []
        });
        wrapper.setProps({
          drawType: 'Text'
        });
        wrapper.instance()._digitizeFeatures = new _Collection["default"]();
        wrapper.instance().createDrawInteraction(true);
        expect(wrapper.instance()._interactions.length).toBe(1);
        expect(wrapper.instance()._interactions[0].type_).toBe('Point');
      });
    });
    describe('#createSelectOrModifyInteraction', function () {
      it('creates OL select or modify interaction depending on provided editType and sets its value(s) to state', function () {
        var wrapper = setupWrapper();
        wrapper.setProps({
          drawType: null,
          editType: 'Delete'
        });
        expect(wrapper.instance()._selectInteraction).toBeNull();
        wrapper.instance().createSelectOrModifyInteraction();
        expect(wrapper.instance()._selectInteraction).toBeDefined();
        expect(wrapper.instance()._selectInteraction.listeners_.select).toBeDefined();
        expect(wrapper.instance()._interactions.length).toBe(1);
        wrapper.setState({
          interactions: null
        });
        wrapper.setProps({
          editType: 'Edit'
        });
        wrapper.instance().createSelectOrModifyInteraction();
        expect(wrapper.instance()._interactions.length).toBe(3);
      });
    });
    describe('#onFeatureRemove', function () {
      it('removes selected feature from the map', function () {
        var wrapper = setupWrapper();
        var feat = new _Feature["default"]();
        var mockEvt = {
          selected: [feat]
        };
        wrapper.instance().createDigitizeLayer();
        wrapper.instance().createSelectOrModifyInteraction();

        wrapper.instance()._digitizeLayer.getSource().addFeature(feat);

        wrapper.instance()._selectInteraction.getFeatures().push(feat);

        expect(wrapper.instance()._selectInteraction.getFeatures().getArray().length).toBe(1);
        expect(wrapper.instance()._digitizeLayer.getSource().getFeaturesCollection().getArray().length).toBe(1);
        wrapper.instance().onFeatureRemove(mockEvt);
        expect(wrapper.instance()._selectInteraction.getFeatures().getArray().length).toBe(0);
        expect(wrapper.instance()._digitizeLayer.getSource().getFeaturesCollection().getArray().length).toBe(0);
      });
    });
    describe('#onFeatureCopy', function () {
      it('calls moveFeature method from AnimateUtil class', function () {
        var wrapper = setupWrapper();
        var feat = new _Feature["default"](new _Point["default"]([0, 0]));
        var mockEvt = {
          selected: [feat]
        };
        wrapper.instance()._digitizeFeatures = new _Collection["default"]();
        var moveFeatureSpy = jest.spyOn(_AnimateUtil["default"], 'moveFeature');
        wrapper.instance().onFeatureCopy(mockEvt);
        expect(moveFeatureSpy).toHaveBeenCalledTimes(1);
        moveFeatureSpy.mockRestore();
      });
    });
    describe('#onModifyStart', function () {
      it('shows prompt for input text if a labeled feature is being modified', function () {
        var wrapper = setupWrapper();
        var feat = new _Feature["default"]();
        feat.set('isLabel', true);
        feat.setStyle(new _Style["default"]({
          text: new _Text["default"]()
        }));
        var mockEvt = {
          features: {}
        };

        mockEvt.features.getArray = function () {
          return [feat];
        };

        wrapper.instance().onModifyStart(mockEvt);
        expect(wrapper.instance()._digitizeTextFeature).toEqual(mockEvt.features.getArray()[0]);
        expect(wrapper.state().showLabelPrompt).toBeTruthy();
      });
    });
    describe('#handleTextAdding', function () {
      it('shows prompt for input text if a labeled feature is being handled', function () {
        var wrapper = setupWrapper();
        var feat = new _Feature["default"]();
        var mockEvt = {
          element: feat
        };
        wrapper.instance().handleTextAdding(mockEvt);
        expect(wrapper.instance()._digitizeTextFeature).toEqual(mockEvt.element);
        expect(wrapper.instance()._digitizeTextFeature.get('isLabel')).toBeTruthy();
        expect(wrapper.state().showLabelPrompt).toBeTruthy();
      });
    });
    describe('#onModalLabelOk', function () {
      it('hides prompt for input text', function () {
        var wrapper = setupWrapper();
        var feat = new _Feature["default"](new _Point["default"]([0, 0]));
        wrapper.setState({
          showLabelPrompt: true
        });
        feat.setStyle(new _Style["default"]({
          text: new _Text["default"]()
        }));
        feat.set('isLabel', true);
        wrapper.instance()._digitizeTextFeature = feat;
        wrapper.instance().onModalLabelOk();
        expect(wrapper.state().showLabelPrompt).toBeFalsy();
      });
    });
    describe('#onModalLabelCancel', function () {
      it('hides prompt for input text and removes _digitizeTextFeature from layer', function () {
        var wrapper = setupWrapper();
        var feat = new _Feature["default"](new _Point["default"]([0, 0]));
        wrapper.setState({
          showLabelPrompt: true
        });
        feat.setStyle(new _Style["default"]({
          text: new _Text["default"]()
        }));
        feat.set('isLabel', true);
        wrapper.instance()._digitizeTextFeature = feat;
        wrapper.instance()._digitizeFeatures = new _Collection["default"]();

        wrapper.instance()._digitizeFeatures.push(feat);

        expect(wrapper.instance()._digitizeFeatures.getLength()).toBe(1);
        wrapper.instance().onModalLabelCancel();
        expect(wrapper.state().showLabelPrompt).toBeFalsy();
        expect(wrapper.instance()._digitizeFeatures.getLength()).toBe(0);
        expect(wrapper.instance()._digitizeTextFeature).toBeNull();
      });
    });
    describe('#setTextOnFeature', function () {
      it('sets label text on feature', function () {
        var wrapper = setupWrapper();
        var feat = new _Feature["default"](new _Point["default"]([0, 0]));
        var label = 'label';
        wrapper.setState({
          textLabel: label
        });
        feat.setStyle(new _Style["default"]({
          text: new _Text["default"]()
        }));
        feat.set('isLabel', true);
        wrapper.instance().setTextOnFeature(feat);
        expect(feat.get('label')).toBe(label);
      });
    });
    describe('#onLabelChange', function () {
      it('sets state value for textLabel', function () {
        var wrapper = setupWrapper();
        var mockEvt = {
          target: {
            value: 'label'
          }
        };
        wrapper.instance().onLabelChange(mockEvt);
        expect(wrapper.state().textLabel).toBe(mockEvt.target.value);
      });
    });
  });
});